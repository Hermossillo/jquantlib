/*
 Copyright (C) 2007 Dominik Holenstein

 This source code is release under the BSD License.
 
 This file is part of JQuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://jquantlib.org/

 JQuantLib is free software: you can redistribute it and/or modify it
 under the terms of the JQuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <jquant-devel@lists.sourceforge.net>. The license is also available online at
 <http://www.jquantlib.org/index.php/LICENSE.TXT>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
 
 JQuantLib is based on QuantLib. http://quantlib.org/
 When applicable, the original copyright notice follows this notice.
 */

package org.jquantlib.testsuite.math.distributions;

// import static org.junit.Assert.assertEquals; --> not JUnit 4.4 conform

import static org.junit.Assert.fail;

import java.lang.reflect.Field;

import org.jquantlib.math.distributions.InverseCumulativeNormal;
import org.jquantlib.math.distributions.alternativeimpls.TESTICN;
import org.junit.Assert;
import org.junit.Test;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * @author Dominik Holenstein
 */

public class InverseCumulativeNormalTest {
	
    private final static Logger logger = LoggerFactory.getLogger(InverseCumulativeNormalTest.class);

	public InverseCumulativeNormalTest() {
		logger.info("\n\n::::: "+this.getClass().getSimpleName()+" :::::");
	}
	
	@Test 
	public void testInverseCumulativNormal_new(){
		logger.info("Running new test");
		
		//normal values generated by quantlib - digits down to 1e-16
		double[][] normal_testvalues = {   {0.01,-2.3263478743880279},
				{0.1, -1.2815515641401563},
				{0.2, -0.84162123272661848},
				{0.3, -0.52440051327929527},
				{0.4, -0.25334710285999862},
				{0.5, 0.00000000000000000},
				{0.6, 0.25334710285999862},
				{0.7, 0.52440051327929516},
				{0.8, 0.84162123272661860},
				{0.9, 1.2815515641401563},
				{0.99, 2.3263478743880279}};
		
		//high precision values generated by quantlib using halleys method - digits down to 1e-16
		double[][] precision_testvalues = {   {0.01,-2.3263478740408416},
				{0.1, -1.2815515655446004},
				{0.2, -0.84162123357291430},
				{0.3, -0.52440051270804078},
				{0.4, -0.25334710313579978},
				{0.5, 0.00000000000000000},
				{0.6, 0.25334710313579961},
				{0.7, 0.52440051270804056},
				{0.8, 0.84162123357291441},
				{0.9, 1.2815515655446004},
				{0.99, 2.3263478740408412}};
		
		InverseCumulativeNormal icn = new InverseCumulativeNormal();
		
		
		//test the normal values
		for (int i = 0; i<normal_testvalues.length; i++){		
			double x_position = normal_testvalues[i][0];
			double tolerance = 1.0e-15;//(Math.abs(x_position)<3.01) ? 1.0e-15: 1.0e-10; 
			
			double normal_expected = normal_testvalues[i][1];
			double computed_normal = icn.evaluate(x_position);
			if (Math.abs(normal_expected-computed_normal)>tolerance) {
				fail("x_position " + x_position + " normal_expected: " + normal_expected + " normal_computed: " + normal_expected);
			}
		}
			
		//turn precision switch on and run again, use reflection 
		final Field fields[] = icn.getClass().getDeclaredFields();
	    for (int i = 0; i < fields.length; ++i) {
	      if ("highPrecision".equals(fields[i].getName())) {
	        try {
	          fields[i].setAccessible(true);
	          fields[i].setBoolean(icn, true);
	        } 
	        catch (IllegalAccessException ex) {}
	      }
	    }

		for (int i = 0; i<precision_testvalues.length; i++){		
			double x_position = precision_testvalues[i][0];
			double tolerance = 1.0e-15;//(Math.abs(x_position)<3.01) ? 1.0e-15: 1.0e-10; 
			
			double precision_expected = precision_testvalues[i][1];
			double computed_precision = icn.evaluate(x_position);
			
			if (Math.abs(precision_expected-computed_precision)>tolerance) {
				fail("x_position " + x_position + " precision_expected: " + precision_expected + " precision_computed: " + computed_precision);
			}
		}
	}
	
	
	
	
	@Test
	public void testInverseCumulativNormal() {
		
		// Test values have been compared with values produced by QuantLibXL in Excel.
		// The error is between 0 and 7.99361E-15 (absolute value).
		// This is the best result compared to Excel, Gnumeric and Quantrix 
		// TODO Fix the error compared to QuantLib
		double[][] testvalues = {   {0.01,-2.326347874388028},
									{0.1, -1.2815515641401563},
									{0.2, -0.8416212327266185},
									{0.3, -0.5244005132792953},
									{0.4, -0.2533471028599986},
									{0.5, 0.0},
									{0.6, 0.2533471028599986},
									{0.7, 0.5244005132792952},
									{0.8, 0.8416212327266186},
									{0.9, 1.2815515641401563},
									{0.99, 2.326347874388028}};
		
									
									
		InverseCumulativeNormal icn = new InverseCumulativeNormal();
		// TESTICN ticn = new TESTICN();
		
		
		for(int i=0;i<testvalues.length;i++){
			double z = testvalues[i][0];
			
			// JQuantLib
			double expected = testvalues[i][1];
			double computed = icn.evaluate(z);
			
			// TESTICN
			double expectedTicn = TESTICN.getInvCDF(z,true);
			double computedTicn = TESTICN.getInvCDF(z,true);
			
			double tolerance = (Math.abs(z)<3.01) ? 1.0e-15: 1.0e-10;
			//double tolerance = (Math.abs(z)<3.01) ? 1.0e-8: 1.0e-8;
			
			// Quantlib/JQuantLib implementation
			if (Math.abs(expected-computed)>tolerance) {
				fail("z: " + z + " expected: " + expected + " computed: " + computed);
			}
			
			// TESTICN implementatation
			if (Math.abs(expectedTicn-computedTicn)>tolerance) {
				fail("z: " + z + " expected: " + expectedTicn + " computed: " + computedTicn);
			}
			
			// JQuantlib
			double realized = computed + icn.evaluate(z)*(-1.0);
			
			// TESTICN
			double realizedTicn = computedTicn + TESTICN.getInvCDF(z,true)*(-1.0);
			
			// Quantlib/JQuantLib implementation
			if (Math.abs(realized) > tolerance) {
				fail("z: " + z + " expected: " + 0.0 + " realized: " + realized);
			}
			
			// TESTICN
			if (Math.abs(realizedTicn) > tolerance) {
				fail("z: " + z + " expected: " + 0.0 + " realized: " + realizedTicn);
			}
			
		    logger.error("***** TEST FAILED - can we remove this testcase and use the new one above?????*****");
		}
	}
	
	@Test 
	public void testExtremes(){
		double z = -40;
		double tolerance = 1.0e-15;
		
		InverseCumulativeNormal icn = new InverseCumulativeNormal();
		
		// assertEquals(0, icn.evaluate(z),tolerance); --> not JUnit 4.4 conform
		if (Math.abs(icn.evaluate(z)) > tolerance) {
			fail("z: " + z + " expected: " + 0.0 + " realized: " + icn.evaluate(z));
		}
		
		z = -10;
		// assertEquals(0, icn.evaluate(z),tolerance); --> not JUnit 4.4 conform
		if (Math.abs(icn.evaluate(z)) > tolerance) {
			fail("z: " + z + " expected: " + 0.0 + " realized: " + icn.evaluate(z));
		}
		
		z = 10;
		//assertEquals(1.0, icn.evaluate(z),tolerance); --> not JUnit 4.4 conform
		if (Math.abs(icn.evaluate(z)) > (tolerance + 1.0)) {
			fail("z: " + z + " expected: " + 1.0 + " realized: " + icn.evaluate(z));
		}
		
		z = 40;
		// assertEquals(1.0, icn.evaluate(z),tolerance); --> not JUnit 4.4 conform
		if (Math.abs(icn.evaluate(z)) > (tolerance + 1.0)) {
			fail("z: " + z + " expected: " + 1.0 + " realized: " + icn.evaluate(z));
		}		
	}
	
}
